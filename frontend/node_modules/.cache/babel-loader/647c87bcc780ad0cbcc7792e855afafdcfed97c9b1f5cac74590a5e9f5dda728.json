{"ast":null,"code":"'use strict';\n\nvar handlers;\nvar wrap = function (target) {\n  if (typeof target === 'object' && target && typeof target.then === 'function' && typeof Proxy !== 'undefined') {\n    // The target needs to be stored internally as a function, so that it can use the `apply` and `construct` handlers.\n    var targetFunc = function () {\n      return target;\n    };\n    targetFunc._promise_chain_cache = Object.create(null);\n    return new Proxy(targetFunc, handlers);\n  }\n  return target;\n};\nif (typeof Proxy !== 'undefined') {\n  if (typeof Reflect === 'undefined') {\n    require('harmony-reflect');\n  }\n  handlers = {\n    get: function (target, property) {\n      if (property === 'inspect') {\n        return function () {\n          return '[chainable Promise]';\n        };\n      }\n      if (property === '_raw') {\n        return target();\n      }\n      if (typeof property === 'symbol') {\n        return target()[property];\n      }\n      // If the Promise itself has the property ('then', 'catch', etc.), return the property itself, bound to the target.\n      // However, wrap the result of calling this function. This allows wrappedPromise.then(something) to also be wrapped.\n      if (property in target()) {\n        if (property !== 'constructor' && !property.startsWith('_') && typeof target()[property] === 'function') {\n          return function () {\n            return wrap(target()[property].apply(target(), arguments));\n          };\n        }\n        return target()[property];\n      }\n      // If the property has a value in the cache, use that value.\n      if (Object.prototype.hasOwnProperty.call(target._promise_chain_cache, property)) {\n        return target._promise_chain_cache[property];\n      }\n      // If the Promise library allows synchronous inspection (bluebird, etc.), ensure that properties of resolved\n      // Promises are also resolved immediately.\n      if (target().isFulfilled && target().isFulfilled() && typeof target().value === 'function') {\n        return wrap(target().constructor.resolve(target().value()[property]));\n      }\n      // Otherwise, return a promise for that property.\n      // Store it in the cache so that subsequent references to that property will return the same promise.\n      target._promise_chain_cache[property] = wrap(target().then(function (result) {\n        if (result && (typeof result === 'object' || typeof result === 'function')) {\n          return wrap(result[property]);\n        }\n        throw new TypeError(\"Promise chain rejection: Cannot read property '\" + property + \"' of \" + result + '.');\n      }));\n      return target._promise_chain_cache[property];\n    },\n    apply: function (target, thisArg, args) {\n      // If the wrapped Promise is called, return a Promise that calls the result\n      return wrap(target().constructor.all([target(), thisArg]).then(function (results) {\n        if (typeof results[0] === 'function') {\n          return wrap(Reflect.apply(results[0], results[1], args));\n        }\n        throw new TypeError('Promise chain rejection: Attempted to call ' + results[0] + ' which is not a function.');\n      }));\n    },\n    construct: function (target, args) {\n      return wrap(target().then(function (result) {\n        return wrap(Reflect.construct(result, args));\n      }));\n    }\n  };\n\n  // Make sure all other references to the proxied object refer to the promise itself, not the function wrapping it\n  Object.getOwnPropertyNames(Reflect).forEach(function (handler) {\n    handlers[handler] = handlers[handler] || function (target, arg1, arg2, arg3) {\n      return Reflect[handler](target(), arg1, arg2, arg3);\n    };\n  });\n}\nmodule.exports = wrap;","map":{"version":3,"names":["handlers","wrap","target","then","Proxy","targetFunc","_promise_chain_cache","Object","create","Reflect","require","get","property","startsWith","apply","arguments","prototype","hasOwnProperty","call","isFulfilled","value","constructor","resolve","result","TypeError","thisArg","args","all","results","construct","getOwnPropertyNames","forEach","handler","arg1","arg2","arg3","module","exports"],"sources":["/Users/zachary/Desktop/reddit-saved-gallery/node_modules/promise-chains/index.js"],"sourcesContent":["'use strict';\nvar handlers;\n\nvar wrap = function (target) {\n  if (typeof target === 'object' && target && typeof target.then === 'function' && typeof Proxy !== 'undefined') {\n    // The target needs to be stored internally as a function, so that it can use the `apply` and `construct` handlers.\n    var targetFunc = function () {\n      return target;\n    };\n    targetFunc._promise_chain_cache = Object.create(null);\n    return new Proxy(targetFunc, handlers);\n  }\n  return target;\n};\n\nif (typeof Proxy !== 'undefined') {\n  if (typeof Reflect === 'undefined') {\n    require('harmony-reflect');\n  }\n  handlers = {\n    get: function (target, property) {\n      if (property === 'inspect') {\n        return function () {\n          return '[chainable Promise]';\n        };\n      }\n      if (property === '_raw') {\n        return target();\n      }\n      if (typeof property === 'symbol') {\n        return target()[property];\n      }\n      // If the Promise itself has the property ('then', 'catch', etc.), return the property itself, bound to the target.\n      // However, wrap the result of calling this function. This allows wrappedPromise.then(something) to also be wrapped.\n      if (property in target()) {\n        if (property !== 'constructor' && !property.startsWith('_') && typeof target()[property] === 'function') {\n          return function () {\n            return wrap(target()[property].apply(target(), arguments));\n          };\n        }\n        return target()[property];\n      }\n      // If the property has a value in the cache, use that value.\n      if (Object.prototype.hasOwnProperty.call(target._promise_chain_cache, property)) {\n        return target._promise_chain_cache[property];\n      }\n      // If the Promise library allows synchronous inspection (bluebird, etc.), ensure that properties of resolved\n      // Promises are also resolved immediately.\n      if (target().isFulfilled && target().isFulfilled() && typeof target().value === 'function') {\n        return wrap(target().constructor.resolve(target().value()[property]));\n      }\n      // Otherwise, return a promise for that property.\n      // Store it in the cache so that subsequent references to that property will return the same promise.\n      target._promise_chain_cache[property] = wrap(target().then(function (result) {\n        if (result && (typeof result === 'object' || typeof result === 'function')) {\n          return wrap(result[property]);\n        }\n        throw new TypeError(\"Promise chain rejection: Cannot read property '\" + property + \"' of \" + result + '.');\n      }));\n      return target._promise_chain_cache[property];\n    },\n    apply: function (target, thisArg, args) {\n      // If the wrapped Promise is called, return a Promise that calls the result\n      return wrap(target().constructor.all([target(), thisArg]).then(function (results) {\n        if (typeof results[0] === 'function') {\n          return wrap(Reflect.apply(results[0], results[1], args));\n        }\n        throw new TypeError('Promise chain rejection: Attempted to call ' + results[0] + ' which is not a function.');\n      }));\n    },\n    construct: function (target, args) {\n      return wrap(target().then(function (result) {\n        return wrap(Reflect.construct(result, args));\n      }));\n    }\n  };\n\n  // Make sure all other references to the proxied object refer to the promise itself, not the function wrapping it\n  Object.getOwnPropertyNames(Reflect).forEach(function (handler) {\n    handlers[handler] = handlers[handler] || function (target, arg1, arg2, arg3) {\n      return Reflect[handler](target(), arg1, arg2, arg3);\n    };\n  });\n}\n\nmodule.exports = wrap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}